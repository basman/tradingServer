package main

import (
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"tradingServer/entity"
	"tradingServer/server"
	"tradingServer/serviceMarket"
	"tradingServer/servicePriceVariation"
	"tradingServer/serviceTrade"
	"tradingServer/serviceUser"
	"tradingServer/storage"
)

func initPriceMakers(ev chan entity.MarketAsset) {
	db := storage.GetDatabase()
	assets, err := db.GetAssets()
	if err != nil {
		log.Fatalf("initPriceMakers() failed to fetch assets: %v", err)
	}

	for _, ass := range assets {
		pm := servicePriceVariation.NewPriceMaker(ass.Name, ass.Price, ev)
		go pm.Run()
	}
}

func runServer() {
	s := server.NewServer()

	f, err := os.OpenFile("tradingServer.log", os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0644)
	if err != nil {
		log.Printf("failed to open or create tradingServer.log: %v", err)
	} else {
		log.SetOutput(f)
	}

	initPriceMakers(s.GetEventInputChannel())
	s.Run()
}

func usage() {
	fmt.Println(`usage: ./tradingServer <command> <options...>
commands:
	adduser <login> [<password>] [<email>]
		Create new user account. Password will be generated and printed to 
		console unless specified.
	log
		Show last 10 combined log messages from access and transaction log.
	resetdb
		Reset database. User accounts, user assets and logs will be deleted.
		Not really needed as database will be initialised automatically upon 
		first operation in case it does not exist.
	setpw <login> [<password>]
		Reset user's password. If no password given, it will be autogenerated
		and printed to console. 
	setemail <login> <email>
		Update user's email address.

Without any sub command given the server will start up and wait for incoming requests.
Database will be created and initialised if it does not exist.`)
}

func main() {
	if len(os.Args) > 1 {
		switch os.Args[1] {
		case "adduser":
			if len(os.Args) < 3 {
				fmt.Printf("missing arguments: %v adduser <login> [<password>] [<email>]\n", os.Args[0])
				os.Exit(1)
			}

			login := os.Args[2]

			password := ""
			if len(os.Args) > 3 {
				password = os.Args[3]
			}

			email := ""
			if len(os.Args) > 4 {
				email = os.Args[4]
			}
			serviceUser.AddUser(login, password, email)
		case "addasset":
			if len(os.Args) < 3 {
				fmt.Printf("missing arguments: %v addasset <name> <price>\n", os.Args[0])
				os.Exit(1)
			}
			name, priceStr := os.Args[2], os.Args[3]
			price, err := strconv.ParseFloat(priceStr, 64)
			if err != nil {
				fmt.Printf("price is not a number: %v", priceStr)
				os.Exit(1)
			}
			err = serviceMarket.AddAsset(name, price)
			if err != nil {
				fmt.Println(err.Error())
				os.Exit(1)
			}
		case "log":
			if len(os.Args) < 3 {
				// show last 10 messages of access log and transaction log
				serviceTrade.ShowLastLog(10)
			} else if os.Args[2] == "dump" {
				// export CSV access log (optional: transactions)
				fmt.Println("no yet implemented")
				os.Exit(1)
			} else if os.Args[2] == "tail" {
				// live tracking of access log
				fmt.Println("no yet implemented")
				os.Exit(1)
			} else {
				fmt.Printf("invalid sub command '%v'\n", os.Args[2])
				os.Exit(1)
			}
		case "resetdb":
			if len(os.Args) > 2 {
				fmt.Printf("invalid arguments: %v (initdb takes no parameters)\n", strings.Join(os.Args[2:], " "))
			}

			serviceUser.RemoveUsers()
			serviceMarket.ResetPrices()
			serviceTrade.ResetLog()
		case "setpw":
			if len(os.Args) < 2 {
				fmt.Printf("missing arguments: %v setpw <login> [<password>]\n", os.Args[0])
				os.Exit(1)
			}
			login := os.Args[2]

			password := ""
			if len(os.Args) > 3 {
				password = os.Args[3]
			}

			serviceUser.ChangeUser(login, password, "")
		case "setemail":
			if len(os.Args) < 3 {
				fmt.Printf("missing arguments: %v setemail <login> <email>\n", os.Args[0])
				os.Exit(1)
			}
			login, email := os.Args[2], os.Args[3]
			serviceUser.ChangeUser(login, "", email)
		case "help":
			fallthrough
		case "-help":
			fallthrough
		case "--help":
			fallthrough
		case "-h":
			usage()
			return
		default:
			log.Fatalf("unknown subcommand '%v'\n", os.Args[1])
		}
	} else {
		runServer()
	}
}
